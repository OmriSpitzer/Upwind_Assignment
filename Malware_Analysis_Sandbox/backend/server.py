from dotenv import load_dotenv
from flask import Flask, jsonify
from flask_cors import CORS
import subprocess
import threading
import time
import os

app = Flask(__name__)
CORS(app)

# Load environment variables
load_dotenv()
VBOX = os.getenv("VBOX_PATH")
VM = os.getenv("VM_NAME")
USER = os.getenv("VM_USERNAME")
PASS = os.getenv("VM_PASSWORD")

# Global variables
LOG_ARR = []                        # Log array for logging actions in VM
STOP_EVENT = threading.Event()      # Event to stop listener thread
LISTENER_THREAD_FILESYSTEM = None   # Listener thread for file system

"""
Running VBox virtual machine
@param args: arguments to pass to VBox
@return: object with boolean success and accomping message
"""
def vbox(*args):
    try:
        r = subprocess.run(
            [VBOX, *args],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="ignore",
            timeout=20,
            creationflags=subprocess.CREATE_NO_WINDOW if os.name == "nt" else 0
        )

        # check if succeeded in starting VM
        if r.returncode == 0:
            return {'success': True, 'message': r.stdout.strip()}
        else:
            return {'success': False, 'message': r.stderr.strip()}
    except Exception as e:
        return {'success': False, 'message':str(e)}

"""
Execute command in VM
@param cmd: command to execute
@return: command output
"""
def guest_bash(cmd):
    response = vbox(
        "guestcontrol", VM, "run",
        "--username", USER,
        "--password", PASS,
        "/bin/bash",
        "--", "-c", cmd
    )
    return response['message'] if response['success'] else ""

"""
Append log entry to log array
@param action: action made
@param network: network snapshot
@param process: process snapshot
@return: None
"""
def log_action(action, network, process=None):
    # Time stamp
    time_stamp = time.strftime("%Y-%m-%d %H:%M:%S")

    # Split action into action and file
    splitted_action = action.split(" ", 1)
    act = splitted_action[0]
    file = splitted_action[1] if len(splitted_action) > 1 else ""

    # Log entry
    LOG_ARR.append({
        "time": time_stamp, 
        "action": act, 
        "file": file, 
        "network": network,
        "process": process
    })

"""
Get network and process snapshot
@return: network and process snapshots
"""
def get_network_and_process_snapshot():
    # Network snapshot
    network = guest_bash("ss -tunap 2>/dev/null || netstat -tunap 2>/dev/null")
    network = network.strip().splitlines()[:12]
    network = "\n".join(network) if network else ""

    # Process snapshot
    process = guest_bash("ps -ef").strip()
    return network, process

"""
Listen to VM for changes and log them
@return: None
"""
def listen():
    home_dir = f"/home/{USER}"

    # infinity loop until stop
    while not STOP_EVENT.is_set():
        # monitor file system for changes (5 seconds timeout)
        file_system = guest_bash(
            f"inotifywait -r -e create,modify,delete --format '%e %w%f' "
            f"--exclude '\\.cache' --exclude '\\.local' --exclude '\\.config' --exclude '\\.gnome' "
            f"-t 5 {home_dir} 2>/dev/null"
        ).strip()

        # Check if stop thread is set
        if STOP_EVENT.is_set():
            break

        # Check if file system is empty
        if not file_system:
            continue  

        # Get network and process snapshot
        network, process = get_network_and_process_snapshot()

        # Log action
        log_action(file_system, network, process=process)

"""
Start listening to VM
@return: True/False if listening
"""
@app.route("/start", methods=["POST"])
def start():
    try:
        # Check VM state first
        info = vbox("showvminfo", VM, "--machinereadable")

        # Check if VM is already running
        vm_running = False
        if info["success"]:
            for line in info["message"].splitlines():
                if line.startswith("VMState="):
                    vm_running = "running" in line
                    break

        # Start VM only if not running
        if not vm_running:
            response = vbox("startvm", VM, "--type", "headless")
            if not response["success"]:
                return jsonify(status=500, message="Failed to start VM", details=response["message"])

            time.sleep(15)
    
        # Clear log array and stop event
        LOG_ARR.clear()
        STOP_EVENT.clear()

        # Start listener thread
        global LISTENER_THREAD_FILESYSTEM
        LISTENER_THREAD_FILESYSTEM = threading.Thread(target=listen, daemon=True)
        LISTENER_THREAD_FILESYSTEM.start()

        return jsonify(status=200, message="VM started successfully")
    except Exception as e:
        return jsonify(status=500, message="Failed to start VM", details=str(e))

"""
Stop listening to VM
@return: True/False if stopped listening
"""
@app.route("/stop", methods=["POST"])
def stop():
    STOP_EVENT.set()

    return jsonify(status=200, message="VM stopped successfully")

"""
Log retreival function 
@return: jsonified log array
"""
@app.route("/logs", methods=["GET"])
def logs():
    print('\n- - - Request for logs - - -')
    return jsonify(status=200, message="Logs retrieved successfully", logs=LOG_ARR)

# Path to the looped bash script (next to server.py)
SCRIPT_DIR = os.path.dirname(os.path.abspath(__file__))
MALWARE_SCRIPT = os.path.join(SCRIPT_DIR, "malware_script.sh")

"""
Run malware in the sandbox
@return: None
"""
@app.route("/runMalware", methods=["POST"])
def runMalware():
    try:
        with open(MALWARE_SCRIPT, "r", encoding="utf-8") as f:
            script = f.read()
        guest_bash(script)

        return jsonify(status=200, message="Malware run successfully")
    except Exception as e:
        return jsonify(status=500, message="Failed to run malware", details=str(e))

if __name__ == "__main__":
    app.run(port=8003, debug=True)
