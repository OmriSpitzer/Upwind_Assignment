from dotenv import load_dotenv
from flask import Flask, jsonify
from flask_cors import CORS
import subprocess
import threading
import time
import os

app = Flask(__name__)
CORS(app)

# Load environment variables
load_dotenv()
VBOX = os.getenv("VBOX_PATH")
VM = os.getenv("VM_NAME")
USER = os.getenv("VM_USERNAME")
PASS = os.getenv("VM_PASSWORD")
MONITOR_DIR = os.getenv("MONITOR_DIR")

# Global variables
LOG_ARR = []                        # Log array for logging actions in VM
STOP_EVENT = threading.Event()      #
STOP_EVENT.set()                    # 
LISTENER_THREAD_FILESYSTEM = None   #

"""
Running VBox virtual machine
@return: object with boolean success and accomping message
"""
def vbox(*args):
    try:
        r = subprocess.run(
            [VBOX, *args],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            text=True,
            encoding="utf-8",
            errors="ignore",
            timeout=20,
            creationflags=subprocess.CREATE_NO_WINDOW if os.name == "nt" else 0
        )

        # check if succeeded in starting VM
        if r.returncode == 0:
            return {'success': True, 'message': r.stdout.strip()}
        else:
            return {'success': False, 'message': r.stderr.strip()}
    except Exception as e:
        return {'success': False, 'message':str(e)}

def guest_bash(cmd):
    response = vbox(
        "guestcontrol", VM, "run",
        "--username", USER,
        "--password", PASS,
        "/bin/bash",
        "--", "-c", cmd
    )
    return response['message'] if response['success'] else ""

def get_process_snapshot():
    """Capture process list from guest VM."""
    return guest_bash(
        "ps -ef"
    ).strip()

def log_action(action, network, process=None):
    time_stamp = time.strftime("%Y-%m-%d %H:%M:%S")
    splitted_action = action.split(" ", 1)
    act = splitted_action[0]
    f = splitted_action[1] if len(splitted_action) > 1 else ""
    entry = {
        "time": time_stamp,
        "action": act,
        "file": f,
        "network": network
    }
    if process:
        entry["process"] = process
    LOG_ARR.append(entry)

def listen_filesystem():
    home_dir = f"/home/{USER}"
    # infinity loop until stop
    while not STOP_EVENT.is_set():
        # monitor file system for changes (5 seconds timeout)
        file_system = guest_bash(
            f"inotifywait -r -e create,modify,delete --format '%e %w%f' "
            f"--exclude '\\.cache' --exclude '\\.local' --exclude '\\.config' --exclude '\\.gnome' "
            f"-t 5 {home_dir} 2>/dev/null"
        ).strip()
        if STOP_EVENT.is_set():
            break
        if not file_system:
            continue  

        raw_network = guest_bash("ss -tunap 2>/dev/null || netstat -tunap 2>/dev/null")
        network_lines = raw_network.strip().splitlines()[:12]
        network = "\n".join(network_lines) if network_lines else ""

        process_snapshot = get_process_snapshot()
        log_action(file_system, network, process=process_snapshot)

"""
Start listening to VM
@return: True/False if listening
"""
@app.route("/start", methods=["POST"])
def start():
    # Check VM state first
    info = vbox("showvminfo", VM, "--machinereadable")

    vm_running = False
    if info["success"]:
        for line in info["message"].splitlines():
            if line.startswith("VMState="):
                vm_running = "running" in line
                break

    # Start VM only if not running
    if not vm_running:
        response = vbox("startvm", VM, "--type", "headless")
        if not response["success"]:
            return jsonify(error="Failed to start VM", details=response["message"]), 500

        time.sleep(15)  # allow OS boot

    LOG_ARR.clear()
    STOP_EVENT.clear()

    global LISTENER_THREAD_FILESYSTEM
    LISTENER_THREAD_FILESYSTEM = threading.Thread(target=listen_filesystem, daemon=True)
    LISTENER_THREAD_FILESYSTEM.start()

    return jsonify({"status": "started", "vm_running": vm_running})

"""
Stop listening to VM
@return: True/False if stopped listening
"""
@app.route("/stop", methods=["POST"])
def stop():
    STOP_EVENT.set()
    return jsonify({"status": "stopped"})

"""
Log retreival function 
@return: jsonified log array
"""
@app.route("/logs", methods=["GET"])
def logs():
    print('\n- - - Request for logs - - -')
    return jsonify(LOG_ARR)

if __name__ == "__main__":
    app.run(port=8003, debug=True)
