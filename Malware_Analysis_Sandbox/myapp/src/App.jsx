import { useState, useEffect, useRef } from "react"
import axios from "axios"
import "./App.css"

// Server URL
const SERVER_URL = "http://localhost:8003"

// Time interval for retrieving logs
const TIME_INTERVAL = 2000

/**
 * Main App component
 * @returns App component
 */
function App() {
  // State variables
  const [isRunning, setIsRunning] = useState(false)         // Flag if the sandbox is running
  const [loading, setLoading] = useState(false)             // Flag if the sandbox is loading
  const [logArray, setLogArray] = useState([])              // Overall logs of the sandbox
  const [alert, setAlert] = useState(null)                  // Alert message

  // Functions
  /**
   * Initialize state variables
   */
  const initializeState = () => {
    setAlert(null)
    setLogArray([])
  }

  /**
  * Fetch the logs of the sandbox
  */
  const fetchLogs = async () => {
    try {
      const response = await axios.get(`${SERVER_URL}/logs`)
      setLogArray(Array.isArray(response.data) ? response.data : [])
    } catch (err) {
      initializeState()
    }
  }

  const start = async () => {
    initializeState()
    setLoading(true)
    try {
      await axios.post(`${SERVER_URL}/start`)
      setIsRunning(true)
    } catch {
      setAlert("Failed to start sandbox")
    } finally {
      setLoading(false)
    }
  }

  const stop = async () => {
    setLoading(true)
    try {
      await axios.post(`${SERVER_URL}/stop`)
      setIsRunning(false)
    } catch {
      setAlert("Failed to stop sandbox")
    } finally {
      setLoading(false)
      initializeState()
    }
  }

  /**
   * Synchronize the status of the sandbox
   */
  useEffect(() => {
    const syncStatus = async () => {
      try {
        const response = await axios.get(`${SERVER_URL}/status`)
        if (response.data?.monitoring) {
          setIsRunning(true)
        }
      } catch {
        setIsRunning(false)
        initializeState()
      }
    }

    syncStatus()
  }, [])

  useEffect(() => {
    if (!isRunning) return

    // Fetch logs every TIME_INTERVAL milliseconds
    const timeoutId = setTimeout(() => {
      fetchLogs()
    }, TIME_INTERVAL)

    // Cleanup function to clear timeout when component unmounts or timer changes
    return () => {
      clearTimeout(timeoutId)
    };

  }, [isRunning])

  return (
    <div className="h-full w-full flex flex-col items-center justify-center">
      <div className="h-2/3 w-3/2 flex flex-col items-center justify-between gap-10 bg-white rounded-md p-10">
        {/* Title */}
        <h1>Malware Analysis Sandbox</h1>

        {/* Start and stop buttons */}
        <button
          className={isRunning ? "btn-stop" : "btn-start"}
          onClick={isRunning ? stop : start}
          disabled={loading}
        >
          {isRunning ? "Stop Listening" : "Start Listening"}
        </button>

        {/* Alert message */}
        {alert && <p className='border-2 rounded-md p-2 text-red-500'>{alert}</p>}

        {/* Log terminal */}
        <div className='h-60 flex flex-col bg-gray-200 rounded-md p-2 w-full overflow-y-auto border-3 border-gray-300'>
          {loading ?
            /* Loading */
            <div className='flex flex-col items-center justify-center h-full'>
              <h2>Loading...</h2>
            </div> :
            (logArray.length === 0 ? (
              /* No logs */
              <div className='flex flex-col items-center justify-center h-full'>
                <h2>
                  {isRunning
                    ? "Waiting for filesystem, network, or process activity…"
                    : "Click “Start Listening” to begin monitoring the VM."}
                </h2>
              </div>
            ) : (
              /* Logs */
              logArray.map((log, index) => (
                <div key={index}>
                  <strong>--- {log.time} ---</strong>
                  {"\n"}
                  <strong>FILESYSTEM:</strong>
                  {"\n"}
                  {log.filesystem || "(none)"}
                  {"\n\n"}
                  <strong>NETWORK:</strong>
                  {"\n"}
                  {log.network || "(none)"}
                  {"\n\n"}
                  <strong>PROCESSES:</strong>
                  {"\n"}
                  {log.processes || "(none)"}
                  {"\n\n"}
                </div>
              ))
            ))}
        </div>
      </div>
    </div>
  )
}

export default App
